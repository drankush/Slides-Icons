/**
 * Generate manifests for all icon libraries
 * This script fetches icon data from various sources and creates JSON manifests
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

const MANIFESTS_DIR = path.join(__dirname, '..', 'src', 'manifests');

// Ensure manifests directory exists
if (!fs.existsSync(MANIFESTS_DIR)) {
    fs.mkdirSync(MANIFESTS_DIR, { recursive: true });
}

// Helper to fetch JSON from URL
function fetchJson(url) {
    return new Promise((resolve, reject) => {
        https.get(url, { headers: { 'User-Agent': 'OpenIcons-Manifest-Generator' } }, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(new Error(`Failed to parse JSON from ${url}`));
                }
            });
        }).on('error', reject);
    });
}

// Helper to fetch text from URL
function fetchText(url) {
    return new Promise((resolve, reject) => {
        https.get(url, { headers: { 'User-Agent': 'OpenIcons-Manifest-Generator' } }, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => resolve(data));
        }).on('error', reject);
    });
}

// Save manifest to file
function saveManifest(name, data) {
    const filePath = path.join(MANIFESTS_DIR, `${name}.json`);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    console.log(`  âœ“ Saved ${name}.json (${data.icons ? Object.keys(data.icons).length : data.length} categories)`);
}

// ============================================
// Health Icons - use existing local manifest
// ============================================
async function generateHealthIconsManifest() {
    console.log('\nðŸ“¦ Health Icons (using existing local manifest)');
    // Already generated by build.js, just copy
    const existingManifest = path.join(__dirname, '..', 'src', 'icons', 'manifest.json');
    if (fs.existsSync(existingManifest)) {
        const data = JSON.parse(fs.readFileSync(existingManifest, 'utf8'));
        saveManifest('healthicons', data);
    } else {
        console.log('  âš  No existing manifest found, run build.js first');
    }
}

// ============================================
// Iconoir - fetch from GitHub API
// ============================================
async function generateIconoirManifest() {
    console.log('\nðŸ“¦ Iconoir');
    try {
        // Fetch the icons directory listing from GitHub
        const url = 'https://api.github.com/repos/iconoir-icons/iconoir/contents/icons';
        const files = await fetchJson(url);

        const icons = files
            .filter(f => f.name.endsWith('.svg'))
            .map(f => ({
                name: f.name.replace('.svg', ''),
                title: f.name.replace('.svg', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
            }));

        saveManifest('iconoir', {
            version: '1.0.0',
            totalIcons: icons.length,
            icons: { 'all': icons }
        });
    } catch (error) {
        console.log(`  âš  Failed to fetch: ${error.message}`);
        // Create fallback minimal manifest
        saveManifest('iconoir', { version: '1.0.0', totalIcons: 0, icons: { 'all': [] } });
    }
}

// ============================================
// Bootstrap Icons - fetch from npm package info
// ============================================
async function generateBootstrapManifest() {
    console.log('\nðŸ“¦ Bootstrap Icons');
    try {
        // Fetch package.json to get icon names
        const url = 'https://raw.githubusercontent.com/twbs/icons/main/font/bootstrap-icons.json';
        const iconsData = await fetchJson(url);

        const icons = Object.keys(iconsData).map(name => ({
            name: name,
            title: name.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
        }));

        saveManifest('bootstrap', {
            version: '1.0.0',
            totalIcons: icons.length,
            icons: { 'all': icons }
        });
    } catch (error) {
        console.log(`  âš  Failed to fetch: ${error.message}`);
        saveManifest('bootstrap', { version: '1.0.0', totalIcons: 0, icons: { 'all': [] } });
    }
}

// ============================================
// Remix Icon - fetch from GitHub
// ============================================
async function generateRemixIconManifest() {
    console.log('\nðŸ“¦ Remix Icon');
    try {
        // Remix Icon has a tags.json with all icon info
        const url = 'https://raw.githubusercontent.com/Remix-Design/RemixIcon/master/tags.json';
        const tagsData = await fetchJson(url);

        // Group by category
        const categories = {};

        for (const [iconName, tags] of Object.entries(tagsData)) {
            // Extract category from icon name (e.g., "arrow-left-line" -> "Arrows")
            const category = tags.category || 'Other';
            if (!categories[category]) {
                categories[category] = [];
            }

            // Remove style suffix for base name
            const baseName = iconName.replace(/-line$|-fill$/, '');

            // Avoid duplicates
            if (!categories[category].find(i => i.name === baseName)) {
                categories[category].push({
                    name: baseName,
                    title: baseName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    keywords: tags.tags || []
                });
            }
        }

        const totalIcons = Object.values(categories).reduce((sum, arr) => sum + arr.length, 0);

        saveManifest('remixicon', {
            version: '1.0.0',
            totalIcons: totalIcons,
            icons: categories
        });
    } catch (error) {
        console.log(`  âš  Failed to fetch: ${error.message}`);
        saveManifest('remixicon', { version: '1.0.0', totalIcons: 0, icons: {} });
    }
}

// ============================================
// Ionicons - fetch from GitHub
// ============================================
async function generateIoniconsManifest() {
    console.log('\nðŸ“¦ Ionicons');
    try {
        // Fetch the SVG directory
        const url = 'https://api.github.com/repos/ionic-team/ionicons/contents/src/svg';
        const files = await fetchJson(url);

        // Extract unique base names (remove -outline, -sharp suffixes)
        const baseNames = new Set();
        files
            .filter(f => f.name.endsWith('.svg'))
            .forEach(f => {
                const name = f.name.replace('.svg', '').replace(/-outline$|-sharp$/, '');
                baseNames.add(name);
            });

        const icons = Array.from(baseNames).map(name => ({
            name: name,
            title: name.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
        }));

        saveManifest('ionicons', {
            version: '1.0.0',
            totalIcons: icons.length,
            icons: { 'all': icons }
        });
    } catch (error) {
        console.log(`  âš  Failed to fetch: ${error.message}`);
        saveManifest('ionicons', { version: '1.0.0', totalIcons: 0, icons: { 'all': [] } });
    }
}

// ============================================
// Boxicons - fetch from GitHub
// ============================================
async function generateBoxiconsManifest() {
    console.log('\nðŸ“¦ Boxicons');
    try {
        // Fetch regular icons as base
        const url = 'https://api.github.com/repos/atisawd/boxicons/contents/svg/regular';
        const files = await fetchJson(url);

        const icons = files
            .filter(f => f.name.endsWith('.svg'))
            .map(f => {
                // Boxicons naming: bx-icon-name.svg
                const name = f.name.replace('.svg', '').replace(/^bx-/, '');
                return {
                    name: name,
                    title: name.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
                };
            });

        saveManifest('boxicons', {
            version: '1.0.0',
            totalIcons: icons.length,
            icons: { 'all': icons }
        });
    } catch (error) {
        console.log(`  âš  Failed to fetch: ${error.message}`);
        saveManifest('boxicons', { version: '1.0.0', totalIcons: 0, icons: { 'all': [] } });
    }
}

// ============================================
// Main
// ============================================
async function main() {
    console.log('ðŸŽ¨ Generating icon manifests for OpenIcons...\n');

    await generateHealthIconsManifest();
    await generateIconoirManifest();
    await generateBootstrapManifest();
    await generateRemixIconManifest();
    await generateIoniconsManifest();
    await generateBoxiconsManifest();

    console.log('\nâœ… All manifests generated!\n');
}

main().catch(console.error);
